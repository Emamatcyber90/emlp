(*
Exercise 3.6.1

Write a function genPoly(n) that generates a polynomial of length n (degree n -
1), all of whose coefficients are 1.0.  Measure the running time of the
straightforward algorithm pmult of Fig 3.27 and the algorithm of Fig 3.30 with
its attendant auxiliaries from Fig 3.27 and Fig 3.28.  The code can be
downloaded from the book's website.  Consider polynomials of length n ranging
from 1 to about 1000 generated by genPoly.  For what value of n does the running
time of komult drop below the running time of pmult?
*)

fun genPoly(0) = nil
  | genPoly(n) = 1.0::genPoly(n - 1);

(* Fig 3.27 follows *)
fun padd(P,   nil) = P
  | padd(nil, Q)   = Q
  | padd((p : real)::ps, q::qs) = (p + q)::padd(ps, qs);

fun smult(nil,            q) = nil
  | smult((p : real)::ps, q) = (p * q)::smult(ps, q);

fun pmult(P, nil) = nil
  | pmult(P, q::qs) = padd(smult(P, q), 0.0::pmult(P, qs));

(* Fig 3.28 follows *)
fun psub(P, Q) = padd(P, smult(Q, ~1.0));

fun length(nil)   = 0
  | length(p::ps) = 1 + length(ps);

fun bestSplit(n, m) =
  if 2 * n <= m then n
  else if 2 * m <= n then m
  else if n <= m then m div 2
  else n div 2;

fun shift(P, 0) = P
  | shift(P, n) = 0.0::shift(P, n - 1);

fun carve(P,     0) = (nil, P)
  | carve(p::ps, n) =
  let
    val (qs, rs) = carve(ps, n - 1)
  in
    (p::qs, rs)
  end;

(* Fig 3.30 follows *)
fun komult(P,   nil) = nil
  | komult(nil, Q)   = nil
  | komult(P,   [q]) = smult(P, q)
  | komult([p], Q)   = smult(Q, p)
  | komult(P, Q)     =
  let
    val n      = length(P);
    val m      = length(Q);
    val s      = bestSplit(n, m);
    val (T, U) = carve(P, s);
    val (V, W) = carve(Q, s);
    val TV     = komult(T, V);
    val UW     = komult(U, W);
    val TUVW   = komult(padd(T, U), padd(V, W));
    val middle = psub(psub(TUVW, TV), UW);
  in
    padd(padd(TV, shift(middle, s)), shift(UW, 2 * s))
  end;

(*
See the associated files, 3.6.1a.sml and 3.6.1.sh.

$ ./3.6/3.6.1.sh 0 100 1000
	komult	pmult
0	0.117	0.109
100	0.109	0.103
200	0.119	0.115
300	0.128	0.129
400	0.125	0.128
500	0.121	0.156
600	0.118	0.189
700	0.124	0.206
800	0.127	0.235
900	0.135	0.289
1000	0.135	0.357

$ ./3.6/3.6.1.sh 380 1 390
	komult	pmult
380	0.118	0.131
381	0.134	0.130
382	0.126	0.133
383	0.119	0.132
384	0.122	0.132
385	0.118	0.127
386	0.121	0.128
387	0.122	0.129
388	0.123	0.132
389	0.128	0.140
390	0.123	0.131

The komult algorithm appears to beat the pmult algorithm at around polynomials
of length 385.
*)
